## 간단 요약

10장 객체 리터럴에서 배운 간단한 객체 생성 방식 외에 생성자 함수를 이용해 객체 생성 방식


## 순서

17.1 Object 생성자 함수

17.2 생성자 함수

17.3 내부 메서드 [[Call]], [[Construct]]

17.4 constructor와 non-constructor의 구분

17.5 new 연산자


## 17.1 Object 생성자 함수

1. new 연산자와 함께 Object 생성자 함수 호출 → 빈 객체 생성 후 반환
2. 빈 객체에 프로퍼티 또는 메서드 추가
3. 객체 완성

```jsx
const person = new Object();

person.name = 'Yang'
person.sayHello = function () {
	...
};
```

## 17.2 생성자 함수

> Q01. 왜 객체 리터럴을 사용 안하고 생성자 함수를 사용해야하는지?

- **생성자 함수**
    
    new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수
    
- **빌트인 생성자 함수**
    
    Object, String, Boolean, Function, Array, Date, RegExp, Promise …
    

반드시 Object 생성자 함수를 사용해 빈 객체를 사용하는 것은 아님.

객체 생성 방법은 객체 리터럴을 사용하는 것이 더 간편함.

- **생성자 함수에 의한 객체 생성 방식의 장점**

생성자 함수에 의한 객체 생성 방식은 마치 인스턴스를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있음.

```jsx
// 생성자 함수
function Circle(radius) {
	this.radius = radius;
	this.getDiameter = function () {
		return 2 * this.radius;
	};
}

const circle1 = new Circle(5);
const circle2 = new Circle(10);
```

- 여기서 잠깐! this
    - this
        
        객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수
        
    - this가 가리키는 값(this 바인딩)
        
        함수 호출 방식에 따라 동적으로 결정됨
        
        | 함수 호출 방식 | this 바인딩 |
        | --- | --- |
        | 일반 함수로서 호출 | 전역 객체 |
        | 메서드로서 호출 | 메서드를 호출한 객체(메서드를 호출한 객체) |
        | 생성자 함수로서 호출 | 생성자 함수(미래에) 생성할 인스턴스 |

- **클래스 기반 객체지향 언어의 생성자와 다른 점**
    
    일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작
    
    만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작
    
    ```jsx
    const circle3 = Circle(15);
    ```
    
    - [ ]  일반함수다
    - [ ]  new 연산자가 없어도 형식이 생성자 함수기에 생성자 함수다
    
    ```jsx
    console.log(circle3);
    ```
    
    - [ ]  undefined
    - [ ]  Object
    
    ```jsx
    console.log(radius)
    ```
    
    - [ ]  undefined
    - [ ]  15
    
- **생성자 함수의 인스턴스 생성 과정**
    
    > 생성자 함수의 함수 몸체에서 수행해야 하는 것
    > 
    > 1. 템플릿(클래스)로서 인스턴스 생성 `필수`
    > 2. 생성된 인스턴스 초기화(인스턴스 프로퍼티 추가 및 초기값 할당) `옵션`
    
    > Q02. 생성자 함수여도 인스턴스를 리턴하는 코드는 없는데요?
    > 
    
    ```jsx
    // 생성자 함수
    function Circle(radius) {
    	this.radius = radius;
    	this.getDiameter = function () {
    		return 2 * this.radius;
    	};
    }
    
    const circle1 = new Circle(5);
    const circle2 = new Circle(10);
    ```
    
    - 1. 인스턴스 생성과 this 바인딩
        
        암묵적으로 빈 객체가 생성됨
        
        여기서 빈 객체는 생성자 함수가 생성한 인스턴스
        
        인스턴스는 this에 바인딩
        
        → 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것 때문
        
        - 바인딩?
            
            식별자와 값을 연결하는 과정
            
            ex 변수 선언
            
            ⇒ 식별자(변수 이름)와 메모리 공간의 주소를 바인딩하는 것
            
            ex this 바인딩
            
            ⇒ this(키워드 이자 식별자)와  this가 가리킬 객체를 바인딩 하는 것
            
    - 2. 인스턴스 초기화
        
        생성자 함수에 기술되어 있는 코드가 한줄씩 실해되면서 this에 바인딩되어 있는 인스턴스를 초기화
        
        즉, this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드 추가하고 
        
        생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값 할당
        
        > Q03. 이 처리는?
        > 
        - [ ]  개발자가 한다
        - [ ]  자바스크립트 엔진이 한다
        - [ ]  브라우저가 한다
    - 3. 인스턴스 반환
        
        생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환
        
        ⇒ 생성자 함수는 this를 암묵적으로 반환한다.
        
        > Q04. 만약 생성자 함수 내부에 return을 작성한다면?
        > 
        - [ ]  return 자체를 작성 못 한다
        - [ ]  return 문에 작성된 객체를 반환한다
        - [ ]  자바스크립트 엔진이 이를 무시하고 this를 반환한다
    

## 17.3 내부 메서드 [[Call]], [[Construct]]

함수는 객체 이므로 일반 객체와 동일하게 동작

함수 객체는 일반 객체가 가지고 있는 내부 슬록과 내부 메서드를 모두 가지고 있기 때문

> Q05. 그럼 함수와 객체의 차이점은?
> 
- 함수
    
    함수로서 동작하기 위한 내부 슬롯 + call, construct 같은 내부 메서드
    

- call 메서드를 갖는 함수 객체
    - callable
    - 호출할 수 있는 객체 (함수)
- construct 메서드를 갖는 함수 객체
    - constructor
    - 생성자 함수로서 호출할 수 있는 함수
- construct 메서드를 갖지 않는 함수 객체
    - non-constructor
    - 객체를 생성자 함수로서 호출할 수 없는 함수

→ 즉, 모든 함수는 내부 메서드 call를 갖고 있어야한다. 

→ but, 모든 함수가 construct를 갖는 것은 아니다.

→ 다시말해, 함수는 construcor일 수도 non-constructor일 수도 있다.


→ 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.

## 17.4 constructor와 non-constructor의 구분

> Q06. 자바스크립트 엔진은 어떻게 구분할까?
> 
- [ ]  함수 정의 방식
- [ ]  함수 실행 방식

- constructor
    - 함수 선언문, 함수 표현식, 클래스
- non-constructor
    - 메서드(ES6 메서드 축약 표현), 화살표 함수

- ECMAScript에서 말하는 메서드
    
    일반적 의미의 메서드 보다 좁음
    
    - 프로퍼티 값으로 할당된 함수 → 일반 함수 o, 메서드 x
    - ES6에서의 메서드 축약 표현으로 작성한 함수 → 메서드 o


## 17.5 new 연산자

- 헷갈리는 내용 다시 정리
    - 일반 함수와 생성자 함수에 특별한 형식적 차이는 x
    - new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작
    - 즉 이 말은 내부 메서드로 call이 호출되는 게 아닌 constructor로 호출
    - 결론, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor여야 함

- 예시로 다시 정리
    
    → 일반 함수와 생성자 함수에 특별한 형식 차이가 없으므로,
    
    생성자 함수는 일반적으로 첫 문자를 대문자로 기술하는 파스칼 케이스로 명명하여
    
    일반 함수와 구별할 수 있도록 하자
    
- **new.target**
    - 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다하더라도 실수가 발생할 수 있기에 ES6부터 지원하는 프로퍼티
    - 파스칼 케이스 컨벤션 사용했는데 new 연산자 없이 사용할 경우 고려
